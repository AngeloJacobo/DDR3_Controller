################################################################################
##
## Filename: ddr3.txt
## {{{
## Project:	10Gb Ethernet switch
##
## Purpose:	To describe how to provide access to an SDRAM controller
##		from the Wishbone bus, where such SDRAM controller uses a
##	different clock from the Wishbone bus itself.
##
## Creator:	Dan Gisselquist, Ph.D.
##		Gisselquist Technology, LLC
##
################################################################################
## }}}
## Copyright (C) 2023, Gisselquist Technology, LLC
## {{{
## This file is part of the ETH10G project.
##
## The ETH10G project contains free software and gateware, licensed under the
## Apache License, Version 2.0 (the "License").  You may not use this project,
## or this file, except in compliance with the License.  You may obtain a copy
## of the License at
## }}}
##	http://www.apache.org/licenses/LICENSE-2.0
## {{{
## Unless required by applicable law or agreed to in writing, files
## distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
## WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
## License for the specific language governing permissions and limitations
## under the License.
##
################################################################################
##
## }}}

# Wishbone 1
@PREFIX=ddr3_controller
@DEVID=DDR3_CONTROLLER
@ACCESS=@$(DEVID)_ACCESS
## LGMEMSZ is the size of the SDRAM in bytes, 29 => 512MB
@$LGMEMSZ=29
@LGMEMSZ.FORMAT=%d
## UNUSED = log_2(512) = 9
@$UNUSED=9
@$NADDR=(1<<(LGMEMSZ-(@$(UNUSED))))
@$NBYTES=(1<<(@$LGMEMSZ))
@NBYTES.FORMAT=0x%08x
@$MADDR= @$(REGBASE)
@MADDR.FORMAT=0x%08x
@SLAVE.TYPE=MEMORY
@SLAVE.BUS=wbwide
@BUS=wbwide
# 8-bit byte accesses
@$ABITS=@$(LGMEMSZ)-@$(UNUSED)
@LD.PERM=wx
#
@REGS.N=1
@REGS.0= 0 R_@$(DEVID) @$(DEVID)
@REGDEFS.H.DEFNS=
#define	@$(DEVID)BASE	@$[0x%08x](REGBASE)
@BDEF.OSDEF=_BOARD_HAS_@$(DEVID)
@BDEF.OSVAL=extern char	_@$(PREFIX)[@$NBYTES];

@TOP.PORTLIST=
		// DDR3 I/O port wires
		o_ddr3_reset_n, o_ddr3_cke, o_ddr3_clk_p, o_ddr3_clk_n,
		o_ddr3_s_n, o_ddr3_ras_n, o_ddr3_cas_n, o_ddr3_we_n,
		o_ddr3_ba, o_ddr3_a,
		o_ddr3_odt, o_ddr3_dm,
		io_ddr3_dqs_p, io_ddr3_dqs_n, io_ddr3_dq
		
		
@TOP.PARAM=
    localparam real CONTROLLER_CLK_PERIOD = 10, //ns, period of clock input to this DDR3 controller module
                    DDR3_CLK_PERIOD = 2.5; //ns, period of clock input to DDR3 RAM device 
    localparam      ROW_BITS = 14,   //width of row address
                    BA_BITS = 3, //width of bank address
                    DQ_BITS = 8,  //width of DQ
                    LANES = 8; //8 lanes of DQ
    localparam      serdes_ratio = $rtoi(CONTROLLER_CLK_PERIOD/DDR3_CLK_PERIOD),
                    wb_data_bits = DQ_BITS*LANES*serdes_ratio*2,
                    wb_sel_bits = wb_data_bits / 8,
                    //4 is the width of a single ddr3 command {cs_n, ras_n, cas_n, we_n} plus 3 (ck_en, odt, reset_n) plus bank bits plus row bits
                    cmd_len = 4 + 3 + BA_BITS + ROW_BITS;


@TOP.IODECL=
	// I/O declarations for the DDR3 SDRAM
	// {{{
	output	wire		o_ddr3_reset_n;
	output	wire	[1:0]	o_ddr3_cke;
	output	wire	[0:0]	o_ddr3_clk_p, o_ddr3_clk_n;
	output	wire	[1:0]   o_ddr3_s_n; // o_ddr3_s_n[1] is set to 0 since controller only support single rank
	output	wire	[0:0]   o_ddr3_ras_n, o_ddr3_cas_n, o_ddr3_we_n;
	output	wire	[BA_BITS-1:0]	o_ddr3_ba;
	output	wire	[15:0]	o_ddr3_a; //set to max of 16 bits, but only ROW_BITS bits are relevant
	output	wire	[1:0]	o_ddr3_odt;
	output	wire	[LANES-1:0]	o_ddr3_dm;
	inout	wire	[(DQ_BITS*LANES)/8-1:0]	io_ddr3_dqs_p, io_ddr3_dqs_n;
	inout	wire	[(DQ_BITS*LANES)-1:0]	io_ddr3_dq;
	// }}}
	
	
@TOP.DEFNS=
	// Wires connected to PHY interface of DDR3 controller
	// {{{
	wire    [DQ_BITS*LANES*8-1:0] @$(PREFIX)_iserdes_data;
    wire    [LANES*8-1:0] @$(PREFIX)_iserdes_dqs;
    wire    [LANES*8-1:0] @$(PREFIX)_iserdes_bitslip_reference;
    wire    @$(PREFIX)_idelayctrl_rdy;
    wire    [cmd_len*serdes_ratio-1:0] @$(PREFIX)_cmd;
    wire    @$(PREFIX)_dqs_tri_control, @$(PREFIX)_dq_tri_control;
    wire    @$(PREFIX)_toggle_dqs;
    wire    [wb_data_bits-1:0] @$(PREFIX)_data;
    wire    [wb_sel_bits-1:0] @$(PREFIX)_dm;
    wire    [4:0] @$(PREFIX)_odelay_data_cntvaluein, @$(PREFIX)_odelay_dqs_cntvaluein;
    wire    [4:0] @$(PREFIX)_idelay_data_cntvaluein, @$(PREFIX)_idelay_dqs_cntvaluein;
    wire    [LANES-1:0] @$(PREFIX)_odelay_data_ld, @$(PREFIX)_odelay_dqs_ld;
    wire    [LANES-1:0] @$(PREFIX)_idelay_data_ld, @$(PREFIX)_idelay_dqs_ld;
    wire    [LANES-1:0] @$(PREFIX)_bitslip;
	// }}}
	
	
@TOP.MAIN=
        // DDR3 Controller-PHY Interface
        @$(PREFIX)_iserdes_data, @$(PREFIX)_iserdes_dqs,
        @$(PREFIX)_iserdes_bitslip_reference,
        @$(PREFIX)_idelayctrl_rdy,
        @$(PREFIX)_cmd,
        @$(PREFIX)_dqs_tri_control, @$(PREFIX)_dq_tri_control,
        @$(PREFIX)_toggle_dqs, @$(PREFIX)_data, @$(PREFIX)_dm,
        @$(PREFIX)_odelay_data_cntvaluein, @$(PREFIX)_odelay_dqs_cntvaluein,
        @$(PREFIX)_idelay_data_cntvaluein, @$(PREFIX)_idelay_dqs_cntvaluein,
        @$(PREFIX)_odelay_data_ld, @$(PREFIX)_odelay_dqs_ld,
        @$(PREFIX)_idelay_data_ld, @$(PREFIX)_idelay_dqs_ld,
        @$(PREFIX)_bitslip
            
            
            
@TOP.INSERT=
    // DDR3 PHY Instantiation
    ddr3_phy #(
            .ROW_BITS(ROW_BITS), //width of row address
            .BA_BITS(BA_BITS), //width of bank address
            .DQ_BITS(DQ_BITS),  //width of DQ
            .LANES(LANES), //8 lanes of DQ
            .CONTROLLER_CLK_PERIOD(CONTROLLER_CLK_PERIOD), //ns, period of clock input to this DDR3 controller module
            .DDR3_CLK_PERIOD(DDR3_CLK_PERIOD) //ns, period of clock input to DDR3 RAM device 
        ) ddr3_phy_inst (
            // clock and reset
            .i_controller_clk(s_clk), 
            .i_ddr3_clk(s_clk4x),
            .i_ref_clk(s_clk200),
            .i_rst_n(!s_reset),
            // Controller Interface
            .i_controller_cmd(@$(PREFIX)_cmd),
            .i_controller_dqs_tri_control(@$(PREFIX)_dqs_tri_control), 
            .i_controller_dq_tri_control(@$(PREFIX)_dq_tri_control),
            .i_controller_toggle_dqs(@$(PREFIX)_toggle_dqs),
            .i_controller_data(@$(PREFIX)_data),
            .i_controller_dm(@$(PREFIX)_dm),
            .i_controller_odelay_data_cntvaluein(@$(PREFIX)_odelay_data_cntvaluein),
            .i_controller_odelay_dqs_cntvaluein(@$(PREFIX)_odelay_dqs_cntvaluein),
            .i_controller_idelay_data_cntvaluein(@$(PREFIX)_idelay_data_cntvaluein),
            .i_controller_idelay_dqs_cntvaluein(@$(PREFIX)_idelay_dqs_cntvaluein),
            .i_controller_odelay_data_ld(@$(PREFIX)_odelay_data_ld), 
            .i_controller_odelay_dqs_ld(@$(PREFIX)_odelay_dqs_ld),
            .i_controller_idelay_data_ld(@$(PREFIX)_idelay_data_ld), 
            .i_controller_idelay_dqs_ld(@$(PREFIX)_idelay_dqs_ld),
            .i_controller_bitslip(@$(PREFIX)_bitslip),
            .o_controller_iserdes_data(@$(PREFIX)_iserdes_data),
            .o_controller_iserdes_dqs(@$(PREFIX)_iserdes_dqs),
            .o_controller_iserdes_bitslip_reference(@$(PREFIX)_iserdes_bitslip_reference),
            .o_controller_idelayctrl_rdy(@$(PREFIX)_idelayctrl_rdy),
            // DDR3 I/O Interface
            .o_ddr3_clk_p(o_ddr3_clk_p),
            .o_ddr3_clk_n(o_ddr3_clk_n),
            .o_ddr3_reset_n(o_ddr3_reset_n),
            .o_ddr3_cke(o_ddr3_cke[0]), // CKE
            .o_ddr3_cs_n(o_ddr3_s_n[0]), // chip select signal (controls rank 1 only)
            .o_ddr3_ras_n(o_ddr3_ras_n), // RAS#
            .o_ddr3_cas_n(o_ddr3_cas_n), // CAS#
            .o_ddr3_we_n(o_ddr3_we_n), // WE#
            .o_ddr3_addr(o_ddr3_a[ROW_BITS-1:0]),
            .o_ddr3_ba_addr(o_ddr3_ba),
            .io_ddr3_dq(io_ddr3_dq),
            .io_ddr3_dqs(io_ddr3_dqs_p),
            .io_ddr3_dqs_n(io_ddr3_dqs_n),
            .o_ddr3_dm(o_ddr3_dm),
            .o_ddr3_odt(o_ddr3_odt[0]) // on-die termination
        );
        assign o_ddr3_s_n[1] = 1; // set to 1 (disabled) since controller only supports single rank
        assign o_ddr3_cke[1] = 0; // set to 0 (disabled) since controller only supports single rank
        assign o_ddr3_odt[1] = 0; // set to 0 (disabled) since controller only supports single rank
        genvar gen_index;
        generate
            for(gen_index = ROW_BITS; gen_index < 16; gen_index = gen_index + 1) begin
                assign o_ddr3_a[gen_index] = 0;
            end
        endgenerate
 	
@MAIN.PORTLIST=
	    // DDR3 Controller Interface
        i_@$(PREFIX)_iserdes_data, i_@$(PREFIX)_iserdes_dqs,
        i_@$(PREFIX)_iserdes_bitslip_reference,
        i_@$(PREFIX)_idelayctrl_rdy,
        o_@$(PREFIX)_cmd,
        o_@$(PREFIX)_dqs_tri_control, o_@$(PREFIX)_dq_tri_control,
        o_@$(PREFIX)_toggle_dqs, o_@$(PREFIX)_data, o_@$(PREFIX)_dm,
        o_@$(PREFIX)_odelay_data_cntvaluein, o_@$(PREFIX)_odelay_dqs_cntvaluein,
        o_@$(PREFIX)_idelay_data_cntvaluein, o_@$(PREFIX)_idelay_dqs_cntvaluein,
        o_@$(PREFIX)_odelay_data_ld, o_@$(PREFIX)_odelay_dqs_ld,
        o_@$(PREFIX)_idelay_data_ld, o_@$(PREFIX)_idelay_dqs_ld,
        o_@$(PREFIX)_bitslip
            
            
@MAIN.PARAM=
    localparam real CONTROLLER_CLK_PERIOD = 10, //ns, period of clock input to this DDR3 controller module
                    DDR3_CLK_PERIOD = 2.5; //ns, period of clock input to DDR3 RAM device 
    localparam      ROW_BITS = 14,   //width of row address
                    COL_BITS = 10, //width of column address
                    BA_BITS = 3, //width of bank address
                    DQ_BITS = 8,  //width of DQ
                    LANES = 8, //8 lanes of DQ
                    AUX_WIDTH = 16;
    localparam      serdes_ratio = $rtoi(CONTROLLER_CLK_PERIOD/DDR3_CLK_PERIOD),
                    wb_data_bits = DQ_BITS*LANES*serdes_ratio*2,
                    wb_sel_bits = wb_data_bits / 8,
                    //4 is the width of a single ddr3 command {cs_n, ras_n, cas_n, we_n} plus 3 (ck_en, odt, reset_n) plus bank bits plus row bits
                    cmd_len = 4 + 3 + BA_BITS + ROW_BITS;
                    
                    
@MAIN.IODECL=
	// DDR3 Controller I/O declarations
	// {{{
    input wire    [DQ_BITS*LANES*8-1:0] i_@$(PREFIX)_iserdes_data;
    input wire    [LANES*8-1:0] i_@$(PREFIX)_iserdes_dqs;
    input wire    [LANES*8-1:0] i_@$(PREFIX)_iserdes_bitslip_reference;
    input wire    i_@$(PREFIX)_idelayctrl_rdy;
    output wire    [cmd_len*serdes_ratio-1:0] o_@$(PREFIX)_cmd;
    output wire    o_@$(PREFIX)_dqs_tri_control, o_@$(PREFIX)_dq_tri_control;
    output wire    o_@$(PREFIX)_toggle_dqs;
    output wire    [wb_data_bits-1:0] o_@$(PREFIX)_data;
    output wire    [wb_sel_bits-1:0] o_@$(PREFIX)_dm;
    output wire    [4:0] o_@$(PREFIX)_odelay_data_cntvaluein, o_@$(PREFIX)_odelay_dqs_cntvaluein;
    output wire    [4:0] o_@$(PREFIX)_idelay_data_cntvaluein, o_@$(PREFIX)_idelay_dqs_cntvaluein;
    output wire    [LANES-1:0] o_@$(PREFIX)_odelay_data_ld, o_@$(PREFIX)_odelay_dqs_ld;
    output wire    [LANES-1:0] o_@$(PREFIX)_idelay_data_ld, o_@$(PREFIX)_idelay_dqs_ld;
    output wire    [LANES-1:0] o_@$(PREFIX)_bitslip;
	// }}}
	
	
@MAIN.INSERT=
	////////////////////////////////////////////////////////////////////////
	//
	// DDR3 Controller instantiation
	// {{{
	    ddr3_controller #(
            .CONTROLLER_CLK_PERIOD(CONTROLLER_CLK_PERIOD), //ns, period of clock input to this DDR3 controller module
            .DDR3_CLK_PERIOD(DDR3_CLK_PERIOD), //ns, period of clock input to DDR3 RAM device 
            .ROW_BITS(ROW_BITS), //width of row address
            .COL_BITS(COL_BITS), //width of column address
            .BA_BITS(BA_BITS), //width of bank address
            .DQ_BITS(DQ_BITS),  //width of DQ
            .LANES(LANES), //8 lanes of DQ
            .AUX_WIDTH(AUX_WIDTH), //
            .OPT_LOWPOWER(1), //1 = low power, 0 = low logic
            .OPT_BUS_ABORT(1)  //1 = can abort bus, 0 = no abort (i_wb_cyc will be ignored, ideal for an AXI implementation which cannot abort transaction)
        ) ddr3_controller_inst (
            .i_controller_clk(i_clk), //i_controller_clk has period of CONTROLLER_CLK_PERIOD 
            .i_rst_n(!i_reset), //200MHz input clock
            // Wishbone 1 (Controller)
            @$(SLAVE.ANSIPORTLIST),
            .i_aux(0),
            .o_aux(),
            // Wishbone 2 (PHY)
            @$(ddr3_phy.SLAVE.ANSIPORTLIST),
            //
            // PHY interface
            .i_phy_iserdes_data(i_@$(PREFIX)_iserdes_data),
            .i_phy_iserdes_dqs(i_@$(PREFIX)_iserdes_dqs),
            .i_phy_iserdes_bitslip_reference(i_@$(PREFIX)_iserdes_bitslip_reference),
            .i_phy_idelayctrl_rdy(i_@$(PREFIX)_idelayctrl_rdy),
            .o_phy_cmd(o_@$(PREFIX)_cmd),
            .o_phy_dqs_tri_control(o_@$(PREFIX)_dqs_tri_control), 
            .o_phy_dq_tri_control(o_@$(PREFIX)_dq_tri_control),
            .o_phy_toggle_dqs(o_@$(PREFIX)_toggle_dqs),
            .o_phy_data(o_@$(PREFIX)_data),
            .o_phy_dm(o_@$(PREFIX)_dm),
            .o_phy_odelay_data_cntvaluein(o_@$(PREFIX)_odelay_data_cntvaluein),
            .o_phy_odelay_dqs_cntvaluein(o_@$(PREFIX)_odelay_dqs_cntvaluein),
            .o_phy_idelay_data_cntvaluein(o_@$(PREFIX)_idelay_data_cntvaluein), 
            .o_phy_idelay_dqs_cntvaluein(o_@$(PREFIX)_idelay_dqs_cntvaluein),
            .o_phy_odelay_data_ld(o_@$(PREFIX)_odelay_data_ld),
            .o_phy_odelay_dqs_ld(o_@$(PREFIX)_odelay_dqs_ld),
            .o_phy_idelay_data_ld(o_@$(PREFIX)_idelay_data_ld), 
            .o_phy_idelay_dqs_ld(o_@$(PREFIX)_idelay_dqs_ld),
            .o_phy_bitslip(o_@$(PREFIX)_bitslip)
        );
	// }}}
	
#
@PREFIX=ddr3_phy
@DEVID=DDR3_PHY
@ACCESS=@$(DEVID)_ACCESS
@$NADDR=1024
@SLAVE.TYPE=MEMORY
@SLAVE.BUS=wb32
@SLAVE.ANSPREFIX=wb2_
# 8-bit byte accesses
@LD.PERM=wx
#
@REGS.N=1
@REGS.0= 0 R_@$(DEVID) @$(DEVID)
@REGDEFS.H.DEFNS=
#define	@$(DEVID)BASE	@$[0x%08x](REGBASE)
@BDEF.OSDEF=_BOARD_HAS_@$(DEVID)
@BDEF.OSVAL=extern char	_@$(PREFIX)[@$NBYTES];


@SIM.INCLUDE=
#include "memsim.h"
@SIM.DEFNS=
#ifdef	@$(ACCESS)
	MEMSIM	*m_@$(PREFIX);
#endif	// @$(ACCESS)
@SIM.INIT=
#ifdef	@$(ACCESS)
		m_@$(PREFIX) = new MEMSIM(@$(NBYTES));
#endif	// @$(ACCESS)
@SIM.CLOCK=@$(SLAVE.BUS.CLOCK.NAME)
@SIM.TICK=
#ifdef	@$(ACCESS)
		// Simulate the SDRAM
		// {{{
		(*m_@$(PREFIX))(m_core->o_@$(PREFIX)_cyc,
			m_core->o_@$(PREFIX)_stb,
			m_core->o_@$(PREFIX)_we,
			m_core->o_@$(PREFIX)_addr,
			&m_core->o_@$(PREFIX)_data,
			m_core->o_@$(PREFIX)_sel,
			m_core->i_@$(PREFIX)_stall,
			m_core->i_@$(PREFIX)_ack,
			&m_core->i_@$(PREFIX)_data);
		m_core->i_@$(PREFIX)_err = 0;
		// }}}
#endif	// @$(ACCESS)
@SIM.LOAD=
			m_@$(PREFIX)->load(start, &buf[offset], wlen);

